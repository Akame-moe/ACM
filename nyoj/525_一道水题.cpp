/*
----------description----------
今天LZQ在玩一种小游戏，但是这游戏数有一点点的大，他一个人玩的累，想多拉一些人进来帮帮他，你能写一个程序帮帮他吗？这个游戏是这样的：有一行数字，如果我们把这行数字中的‘5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。  
你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出，大家赶紧写个程序来帮帮LZQ吧！  


----------input----------
输入包含多组测试用例，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于5000。  
  
输入数据保证：分割得到的非负整数不会大于100000000；如果有输入数据全为5，则输出0。  
  


----------output----------
对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。  
  


----------sample_input----------
0051231232050775
----------sample_putput----------
0 77 12312320
*/
/////////////////////////////
#include<stdio.h>
#include<stdlib.h>
char s[5005];
int ss[2500];
int comp(const void *a,const void *b)
{
    return *(int *)a-*(int *)b;
}
int main()
{
    int len,t,i,temp;
    while(~scanf("%s",s))
    {
        t=0;        
        for(i=0;s[i]!='\0';)
        {    
            while(s[i]=='5')
                i++;
            temp=0;
            while(s[i]!='\0' && s[i]!='5')
            {
                temp=temp*10+(s[i]-'0');
                i++;
            }
            ss[t++]=temp;
            while(s[i]=='5')
                i++;
        }
        qsort(ss,t,sizeof(int),comp);
        printf("%d",ss[0]);
        for(i=1;i<t;i++)
            printf(" %d",ss[i]);
        printf("\n");
    }
    return 0;
}
